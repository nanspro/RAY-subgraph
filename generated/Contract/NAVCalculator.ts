// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  EthereumCall,
  EthereumEvent,
  SmartContract,
  EthereumValue,
  JSONValue,
  TypedMap,
  Entity,
  EthereumTuple,
  Bytes,
  Address,
  BigInt,
  CallResult
} from "@graphprotocol/graph-ts";

export class NAVCalculator__calculatePayableAmountResult {
  value0: boolean;
  value1: BigInt;

  constructor(value0: boolean, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromBoolean(this.value0));
    map.set("value1", EthereumValue.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class NAVCalculator__getTokenValueResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromUnsignedBigInt(this.value0));
    map.set("value1", EthereumValue.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class NAVCalculator extends SmartContract {
  static bind(address: Address): NAVCalculator {
    return new NAVCalculator("NAVCalculator", address);
  }

  deprecated(): boolean {
    let result = super.call("deprecated", []);

    return result[0].toBoolean();
  }

  try_deprecated(): CallResult<boolean> {
    let result = super.tryCall("deprecated", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  _storage(): Address {
    let result = super.call("_storage", []);

    return result[0].toAddress();
  }

  try__storage(): CallResult<Address> {
    let result = super.tryCall("_storage", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  getPricePerShare(portfolioId: Bytes, unrealizedYield: BigInt): BigInt {
    let result = super.call("getPricePerShare", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromUnsignedBigInt(unrealizedYield)
    ]);

    return result[0].toBigInt();
  }

  try_getPricePerShare(
    portfolioId: Bytes,
    unrealizedYield: BigInt
  ): CallResult<BigInt> {
    let result = super.tryCall("getPricePerShare", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromUnsignedBigInt(unrealizedYield)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getTotalYieldPerShare(portfolioId: Bytes, unrealizedYield: BigInt): BigInt {
    let result = super.call("getTotalYieldPerShare", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromUnsignedBigInt(unrealizedYield)
    ]);

    return result[0].toBigInt();
  }

  try_getTotalYieldPerShare(
    portfolioId: Bytes,
    unrealizedYield: BigInt
  ): CallResult<BigInt> {
    let result = super.tryCall("getTotalYieldPerShare", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromUnsignedBigInt(unrealizedYield)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getTotalYield(
    unrealizedYield: BigInt,
    realizedYield: BigInt,
    withdrawnYield: BigInt
  ): BigInt {
    let result = super.call("getTotalYield", [
      EthereumValue.fromUnsignedBigInt(unrealizedYield),
      EthereumValue.fromUnsignedBigInt(realizedYield),
      EthereumValue.fromUnsignedBigInt(withdrawnYield)
    ]);

    return result[0].toBigInt();
  }

  try_getTotalYield(
    unrealizedYield: BigInt,
    realizedYield: BigInt,
    withdrawnYield: BigInt
  ): CallResult<BigInt> {
    let result = super.tryCall("getTotalYield", [
      EthereumValue.fromUnsignedBigInt(unrealizedYield),
      EthereumValue.fromUnsignedBigInt(realizedYield),
      EthereumValue.fromUnsignedBigInt(withdrawnYield)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getPortfolioUnrealizedYield(portfolioId: Bytes): BigInt {
    let result = super.call("getPortfolioUnrealizedYield", [
      EthereumValue.fromFixedBytes(portfolioId)
    ]);

    return result[0].toBigInt();
  }

  try_getPortfolioUnrealizedYield(portfolioId: Bytes): CallResult<BigInt> {
    let result = super.tryCall("getPortfolioUnrealizedYield", [
      EthereumValue.fromFixedBytes(portfolioId)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getOpportunityUnrealizedYield(
    portfolioId: Bytes,
    amountToWithdraw: BigInt
  ): BigInt {
    let result = super.call("getOpportunityUnrealizedYield", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromUnsignedBigInt(amountToWithdraw)
    ]);

    return result[0].toBigInt();
  }

  try_getOpportunityUnrealizedYield(
    portfolioId: Bytes,
    amountToWithdraw: BigInt
  ): CallResult<BigInt> {
    let result = super.tryCall("getOpportunityUnrealizedYield", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromUnsignedBigInt(amountToWithdraw)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getOpportunityYield(
    portfolioId: Bytes,
    opportunityId: Bytes,
    amountToWithdraw: BigInt
  ): BigInt {
    let result = super.call("getOpportunityYield", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromFixedBytes(opportunityId),
      EthereumValue.fromUnsignedBigInt(amountToWithdraw)
    ]);

    return result[0].toBigInt();
  }

  try_getOpportunityYield(
    portfolioId: Bytes,
    opportunityId: Bytes,
    amountToWithdraw: BigInt
  ): CallResult<BigInt> {
    let result = super.tryCall("getOpportunityYield", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromFixedBytes(opportunityId),
      EthereumValue.fromUnsignedBigInt(amountToWithdraw)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getOpportunityBalance(portfolioId: Bytes, opportunityId: Bytes): BigInt {
    let result = super.call("getOpportunityBalance", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromFixedBytes(opportunityId)
    ]);

    return result[0].toBigInt();
  }

  try_getOpportunityBalance(
    portfolioId: Bytes,
    opportunityId: Bytes
  ): CallResult<BigInt> {
    let result = super.tryCall("getOpportunityBalance", [
      EthereumValue.fromFixedBytes(portfolioId),
      EthereumValue.fromFixedBytes(opportunityId)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  calculatePayableAmount(
    principalToken: Address,
    value: BigInt
  ): NAVCalculator__calculatePayableAmountResult {
    let result = super.call("calculatePayableAmount", [
      EthereumValue.fromAddress(principalToken),
      EthereumValue.fromUnsignedBigInt(value)
    ]);

    return new NAVCalculator__calculatePayableAmountResult(
      result[0].toBoolean(),
      result[1].toBigInt()
    );
  }

  try_calculatePayableAmount(
    principalToken: Address,
    value: BigInt
  ): CallResult<NAVCalculator__calculatePayableAmountResult> {
    let result = super.tryCall("calculatePayableAmount", [
      EthereumValue.fromAddress(principalToken),
      EthereumValue.fromUnsignedBigInt(value)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new NAVCalculator__calculatePayableAmountResult(
        value[0].toBoolean(),
        value[1].toBigInt()
      )
    );
  }

  onlyTokenOwner(
    tokenId: Bytes,
    origCaller: Address,
    msgSender: Address
  ): Address {
    let result = super.call("onlyTokenOwner", [
      EthereumValue.fromFixedBytes(tokenId),
      EthereumValue.fromAddress(origCaller),
      EthereumValue.fromAddress(msgSender)
    ]);

    return result[0].toAddress();
  }

  try_onlyTokenOwner(
    tokenId: Bytes,
    origCaller: Address,
    msgSender: Address
  ): CallResult<Address> {
    let result = super.tryCall("onlyTokenOwner", [
      EthereumValue.fromFixedBytes(tokenId),
      EthereumValue.fromAddress(origCaller),
      EthereumValue.fromAddress(msgSender)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  getTokenValue(
    typeId: Bytes,
    tokenId: Bytes
  ): NAVCalculator__getTokenValueResult {
    let result = super.call("getTokenValue", [
      EthereumValue.fromFixedBytes(typeId),
      EthereumValue.fromFixedBytes(tokenId)
    ]);

    return new NAVCalculator__getTokenValueResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getTokenValue(
    typeId: Bytes,
    tokenId: Bytes
  ): CallResult<NAVCalculator__getTokenValueResult> {
    let result = super.tryCall("getTokenValue", [
      EthereumValue.fromFixedBytes(typeId),
      EthereumValue.fromFixedBytes(tokenId)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new NAVCalculator__getTokenValueResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getPortfolioPricePerShare(portfolioId: Bytes): BigInt {
    let result = super.call("getPortfolioPricePerShare", [
      EthereumValue.fromFixedBytes(portfolioId)
    ]);

    return result[0].toBigInt();
  }

  try_getPortfolioPricePerShare(portfolioId: Bytes): CallResult<BigInt> {
    let result = super.tryCall("getPortfolioPricePerShare", [
      EthereumValue.fromFixedBytes(portfolioId)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getOpportunityPricePerShare(opportunityId: Bytes): BigInt {
    let result = super.call("getOpportunityPricePerShare", [
      EthereumValue.fromFixedBytes(opportunityId)
    ]);

    return result[0].toBigInt();
  }

  try_getOpportunityPricePerShare(opportunityId: Bytes): CallResult<BigInt> {
    let result = super.tryCall("getOpportunityPricePerShare", [
      EthereumValue.fromFixedBytes(opportunityId)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends EthereumCall {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get __storage(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class UpdateYieldCall extends EthereumCall {
  get inputs(): UpdateYieldCall__Inputs {
    return new UpdateYieldCall__Inputs(this);
  }

  get outputs(): UpdateYieldCall__Outputs {
    return new UpdateYieldCall__Outputs(this);
  }
}

export class UpdateYieldCall__Inputs {
  _call: UpdateYieldCall;

  constructor(call: UpdateYieldCall) {
    this._call = call;
  }

  get portfolioId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  // get yield(): BigInt {
  //   return this._call.inputValues[1].value.toBigInt();
  // }
}

export class UpdateYieldCall__Outputs {
  _call: UpdateYieldCall;

  constructor(call: UpdateYieldCall) {
    this._call = call;
  }
}

export class SetDeprecatedCall extends EthereumCall {
  get inputs(): SetDeprecatedCall__Inputs {
    return new SetDeprecatedCall__Inputs(this);
  }

  get outputs(): SetDeprecatedCall__Outputs {
    return new SetDeprecatedCall__Outputs(this);
  }
}

export class SetDeprecatedCall__Inputs {
  _call: SetDeprecatedCall;

  constructor(call: SetDeprecatedCall) {
    this._call = call;
  }

  get value(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetDeprecatedCall__Outputs {
  _call: SetDeprecatedCall;

  constructor(call: SetDeprecatedCall) {
    this._call = call;
  }
}
